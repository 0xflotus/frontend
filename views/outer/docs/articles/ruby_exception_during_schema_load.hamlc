%article
  - @article_tags = ['troubleshooting', 'ruby']

  = HAML['article_title']({title: "rake db:schema:load fails", icon: "icon-random"})

  .doc
    %p
      If your build fails during the
      %code
        rake db:schema:create db:schema:load
      step, there is usually a straightforward fix.

    %h2 Identifying the problem
    %p
      Usually, this error looks like
    %pre<>
      :preserve>
        ** Invoke db:create (first_time)
        ** Invoke db:load_config (first_time)
        ** Execute db:load_config
        ** Invoke rails_env (first_time)
        ** Execute rails_env
        ** Execute db:create
        ** Invoke db:schema:load (first_time)
        ** Invoke environment (first_time)
        ** Execute environment
        rake aborted!
        PG::Error: ERROR:  relation "users" does not exist
        LINE 4:              WHERE a.foo = '"users"'::regclass
                                      ^
        SELECT a.attname, format_type(a.atttypid, a.atttypmod), d.adsrc, a.attnotnull
              FROM pg_attribute a LEFT JOIN pg_attrdef d
                ON a.attrelid = d.adrelid AND a.attnum = d.adnum
             WHERE a.attrelid = '"users"'::regclass
               AND a.attnum > 0 AND NOT a.attisdropped
             ORDER BY a.attnum
        /home/ubuntu/FooBar/vendor/bundle/ruby/1.9.1/gems/activerecord-3.2.6/lib/active_record/connection_adapters/postgresql_adapter.rb:1151:in `async_exec'


    %h2
      Understanding ActiveRecord Introspection
    %p
      Most of the magic that ActiveRecord provides comes from
      examining the database tables. Obviously, if your database
      hasn't been created yet, things are not going to work well.
    %p
      On Circle, every build runs in a clean VM, so at the start of
      the build, your rails database doesn't exist yet.

    %h2
      The Solution
    %p
      The solution is to make sure that
      %b
        no ActiveRecord models are loaded during rake db:schema:load

      There are many ways to trigger this bug, but the two most common are
      %ul
        %li calling class methods on ActiveRecord code during rails configuration
        %li requiring test code (such as spec/factories.rb) at file scope

      You should only require test code when in the test environment,
      and code that refers to models should be moved into
      initializers. As a happy side-effect, your rails boot time
      should decrease!

    %h2 Identifying the Source
    %p
      If you have this problem, how do you figure out what line is responsible? By reading the stacktrace!
    %pre
      %code<>
        :preserve
          vendor/bundle/ruby/1.9.1/gems/activerecord-3.2.6/lib/active_record/connection_adapters/postgresql_adapter.rb:1151:in `async_exec'
          ...
          vendor/bundle/ruby/1.9.1/gems/activerecord-3.2.6/lib/active_record/base.rb:482:in `initialize'
          vendor/bundle/ruby/1.9.1/gems/factory_girl-4.1.0/lib/factory_girl/decorator/new_constructor.rb:9:in `new'
          ...
          vendor/bundle/ruby/1.9.1/gems/factory_girl-4.1.0/lib/factory_girl/factory_runner.rb:23:in `block in run'
          ...
          spec/factories.rb:3:in `&lttop (required)&gt'
          ...
          vendor/bundle/ruby/1.9.1/gems/railties-3.2.6/lib/rails/railtie/configurable.rb:30:in `method_missing'
          config/environment.rb:5:in `&lttop (required)&gt'
          vendor/bundle/ruby/1.9.1/gems/activesupport-3.2.6/lib/active_support/dependencies.rb:251:in `require'
          vendor/bundle/ruby/1.9.1/gems/activesupport-3.2.6/lib/active_support/dependencies.rb:251:in `block in require'

    %p
      Here, we can see that config/environment.rb loads, which then
      requires spec/factories.rb, which loads activerecord. The
      solution then, is to refactor the code in such a way that
      spec/factories.rb isn't loaded unless the app is actually
      started.

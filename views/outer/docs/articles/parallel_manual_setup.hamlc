%article
  - @article_tags = ['parallelism']

  = HAML['article_title']({title: "Manually Setting Up Parallelism", icon: "icon-cogs", lastUpdated: "Feb 2, 2013", subtitle: "Partition your tests across N boxes"})

  .doc
    %p
      If you want the benefits of parallel testing, and you're not
      using one of our automatically supported test runners, or if
      you've overridden our test commands, you'll need to do some
      extra work to make parallelism work.

    %h2 Circle Env Vars
    %p
      The environment variables
      %code
        CIRCLE_NODE_INDEX
      and
      %code
        CIRCLE_NODE_TOTAL

      are exported. Your test runner should choose to run a subset
      of your tests, on each node.

    %h2 A simple example
    %pre
      %code<>
        :preserve<>
          test:
            override:
              - [ $CIRCLE_NODE_INDEX == 0 ] && bundle exec rake spec:core
              - [ $CIRCLE_NODE_INDEX == 1 ] && bundle exec rake spec:integration

    %p
      Obviously, this is slightly limited because it's hard-coded to
      only work with two nodes, and the test time might not balance
      across all nodes equally.

    %h2 Balancing

    %p
      A more powerful version evenly splits all test files across N nodes. We recommend you write a script that does something like
    %pre
      %code<>
        :preserve<>
          #!/bin/bash

          i=0
          files=()
          for file in $(find ./test -name "*.py")
          do
            if [ $(($i % $CIRCLE_NODE_TOTAL)) -eq $CIRCLE_NODE_INDEX ]
            then
              files+=" $file"
            fi
            ((i++))
          done

          test-runner ${files[@]}

    %p
      This script partitions the test files into N equally sized buckets, and calls "test-runner" on the bucket for this machine.

    %h2 Contact Us
    %p

      If you set this up for a library or framework that we should be
      able to infer automatically, i.e. if you're using the standard
      test runner, please let us know! We are always interested in
      adding support for new languages and frameworks.
